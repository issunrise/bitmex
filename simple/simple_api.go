/*
 * BitMEX API
 *
 * ## REST API for the BitMEX Trading Platform  [Changelog](/app/apiChangelog)    #### Getting Started   ##### Fetching Data  All REST endpoints are documented below. You can try out any query right from this interface.  Most table queries accept `count`, `start`, and `reverse` params. Set `reverse=true` to get rows newest-first.  Additional documentation regarding filters, timestamps, and authentication is available in [the main API documentation](https://www.bitmex.com/app/restAPI).  *All* table data is available via the [Websocket](/app/wsAPI). We highly recommend using the socket if you want to have the quickest possible data without being subject to ratelimits.  ##### Return Types  By default, all data is returned as JSON. Send `?_format=csv` to get CSV data or `?_format=xml` to get XML data.  ##### Trade Data Queries  *This is only a small subset of what is available, to get you started.*  Fill in the parameters and click the `Try it out!` button to try any of these queries.  * [Pricing Data](#!/Quote/Quote_get)  * [Trade Data](#!/Trade/Trade_get)  * [OrderBook Data](#!/OrderBook/OrderBook_getL2)  * [Settlement Data](#!/Settlement/Settlement_get)  * [Exchange Statistics](#!/Stats/Stats_history)  Every function of the BitMEX.com platform is exposed here and documented. Many more functions are available.  -  ## All API Endpoints  Click to expand a section.
 *
 * OpenAPI spec version: 1.2.0
 * Contact: support@bitmex.com
 * Generated by: https://github.com/sunrisedo/bitmex.git
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package simple

import (
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"net"
	"strconv"
	// "log"
	"net/http"
	"net/url"

	"golang.org/x/net/proxy"
)

const (
	SimplePath = "https://www.bitmex.com/api/v1"
)

type ErrorRep struct {
	err ErrorInfo `json:"error,omitempty"`
}

type ErrorInfo struct {
	Message string `json:"message,omitempty"`
	Name    string `json:"name,omitempty"`
}

type SimpleApi struct {
	// ProxyUrl  *url.URL
	NetDial func(string, string) (net.Conn, error)
}

func NewSimpleApi() *SimpleApi {
	return &SimpleApi{}
}

func (c *SimpleApi) SetAgent(dialer proxy.Dialer) *SimpleApi {
	if dialer != nil {
		c.NetDial = dialer.Dial
	}
	// link, _ := url.Parse(SimplePath)
	// log.Println("SetAgent", link.Host)
	// c.NetDial = func(net, addr string) (conn net.Conn, err error) {
	// 	return dialer.Dial("tcp", fmt.Sprintf("%s:443", link.Host))
	// }

	return c
}

func (c *SimpleApi) FundingGet(symbol string, count float32, reverse bool) ([]Funding, error) {

	queryParams := url.Values{}
	// add default headers if any
	queryParams.Add("symbol", symbol)
	queryParams.Add("count", fmt.Sprintf("%.0f", count))
	queryParams.Add("reverse", strconv.FormatBool(reverse))

	// set Accept header
	client := &http.Client{}
	// log.Println("NetDial", c.NetDial)
	if c.NetDial != nil {
		// log.Println("FundingGet use agent")
		client.Transport = &http.Transport{Dial: c.NetDial}
	}
	// if c.ProxyUrl != nil {
	// 	client.Transport = &http.Transport{Proxy: http.ProxyURL(c.ProxyUrl)}
	// }
	// client := &http.Client{}
	reqest, _ := http.NewRequest("GET", fmt.Sprintf("%s/funding?%s", SimplePath, queryParams.Encode()), nil)
	httpResponse, err := client.Do(reqest)
	if err != nil {
		log.Println("get FundingGet error:", err)
		// SendError(&DingSend{Type: "Get coincola.com ETH price", Msg: errs.Error()})
		return nil, err
	}

	defer httpResponse.Body.Close()
	data, err := ioutil.ReadAll(httpResponse.Body)
	if err != nil {
		log.Println("get body error:", err)
	}
	if httpResponse.StatusCode != 200 {
		// log.Println("httpResponse.Body()", string(data))
		rep := new(ErrorRep)
		json.Unmarshal(data, &rep)
		return nil, errors.New(fmt.Sprintf("%s,%s", rep.err.Name, rep.err.Message))
	}
	rep := new([]Funding)
	// log.Println("PositionGet Json:", string(httpResponse.Body()))
	err = json.Unmarshal(data, &rep)
	return *rep, err
}

func (c *SimpleApi) InsuranceGet(count float32, reverse bool) ([]Insurance, error) {

	queryParams := url.Values{}
	// add default headers if any
	queryParams.Add("count", fmt.Sprintf("%.0f", count))
	queryParams.Add("reverse", strconv.FormatBool(reverse))

	// set Accept header
	client := &http.Client{}
	if c.NetDial != nil {
		client.Transport = &http.Transport{Dial: c.NetDial}
	}

	// if c.ProxyUrl != nil {
	// 	client.Transport = &http.Transport{Proxy: http.ProxyURL(c.ProxyUrl)}
	// }
	// client := &http.Client{Transport: c.Transport}
	// client := &http.Client{}
	reqest, _ := http.NewRequest("GET", fmt.Sprintf("%s/insurance?%s", SimplePath, queryParams.Encode()), nil)
	httpResponse, err := client.Do(reqest)
	if err != nil {
		log.Println("get InsuranceGet error:", err)
		// SendError(&DingSend{Type: "Get coincola.com ETH price", Msg: errs.Error()})
		return nil, err
	}

	defer httpResponse.Body.Close()
	data, err := ioutil.ReadAll(httpResponse.Body)
	if err != nil {
		log.Println("get body error:", err)
	}
	if httpResponse.StatusCode != 200 {
		// log.Println("httpResponse.Body()", string(data))
		rep := new(ErrorRep)
		json.Unmarshal(data, &rep)
		return nil, errors.New(fmt.Sprintf("%s,%s", rep.err.Name, rep.err.Message))
	}
	var rep []Insurance
	// log.Println("PositionGet Json:", string(httpResponse.Body()))
	err = json.Unmarshal(data, &rep)
	if len(rep) == 0 || err != nil {
		return nil, errors.New(fmt.Sprintf("insurances data error %v. data:%s", err, string(data)))
	}
	return rep, nil
}
