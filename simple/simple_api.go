/*
 * BitMEX API
 *
 * ## REST API for the BitMEX Trading Platform  [Changelog](/app/apiChangelog)    #### Getting Started   ##### Fetching Data  All REST endpoints are documented below. You can try out any query right from this interface.  Most table queries accept `count`, `start`, and `reverse` params. Set `reverse=true` to get rows newest-first.  Additional documentation regarding filters, timestamps, and authentication is available in [the main API documentation](https://www.bitmex.com/app/restAPI).  *All* table data is available via the [Websocket](/app/wsAPI). We highly recommend using the socket if you want to have the quickest possible data without being subject to ratelimits.  ##### Return Types  By default, all data is returned as JSON. Send `?_format=csv` to get CSV data or `?_format=xml` to get XML data.  ##### Trade Data Queries  *This is only a small subset of what is available, to get you started.*  Fill in the parameters and click the `Try it out!` button to try any of these queries.  * [Pricing Data](#!/Quote/Quote_get)  * [Trade Data](#!/Trade/Trade_get)  * [OrderBook Data](#!/OrderBook/OrderBook_getL2)  * [Settlement Data](#!/Settlement/Settlement_get)  * [Exchange Statistics](#!/Stats/Stats_history)  Every function of the BitMEX.com platform is exposed here and documented. Many more functions are available.  -  ## All API Endpoints  Click to expand a section.
 *
 * OpenAPI spec version: 1.2.0
 * Contact: support@bitmex.com
 * Generated by: https://github.com/sunrisedo/bitmex.git
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package simple

import (
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"strconv"

	"golang.org/x/net/proxy"
)

type ErrorRep struct {
	err ErrorInfo `json:"error,omitempty"`
}

type ErrorInfo struct {
	Message string `json:"message,omitempty"`
	Name    string `json:"name,omitempty"`
}

type SimpleApi struct {
	url    string
	client *http.Client
}

func NewSimpleApi(dialer ...proxy.Dialer) *SimpleApi {
	client := http.DefaultClient
	if len(dialer) > 0 {
		if dialer[0] != nil {
			client.Transport = &http.Transport{Dial: dialer[0].Dial}
		}
	}
	return &SimpleApi{
		url:    "https://www.bitmex.com/api/v1",
		client: client,
	}
}

func (c *SimpleApi) SetTest() *SimpleApi {
	c.url = "https://testnet.bitmex.com/api/v1"
	return c
}

func (c *SimpleApi) FundingGet(symbol string, count float32, reverse bool) ([]Funding, error) {

	queryParams := url.Values{}
	// add default headers if any
	queryParams.Add("symbol", symbol)
	queryParams.Add("count", fmt.Sprintf("%.0f", count))
	queryParams.Add("reverse", strconv.FormatBool(reverse))

	reqest, _ := http.NewRequest("GET", fmt.Sprintf("%s/funding?%s", c.url, queryParams.Encode()), nil)
	httpResponse, err := c.client.Do(reqest)
	if err != nil {
		return nil, errors.New(fmt.Sprintf("funding request error %v", err))
	}

	defer httpResponse.Body.Close()
	data, err := ioutil.ReadAll(httpResponse.Body)
	if err != nil {
		log.Println("funding body error:", err)
	}
	if httpResponse.StatusCode != 200 {
		// log.Println("httpResponse.Body()", string(data))
		rep := new(ErrorRep)
		json.Unmarshal(data, &rep)
		return nil, errors.New(fmt.Sprintf("%s,%s", rep.err.Name, rep.err.Message))
	}
	rep := []Funding{}
	// log.Println("PositionGet Json:", string(httpResponse.Body()))
	err = json.Unmarshal(data, &rep)
	return rep, err
}

func (c *SimpleApi) InsuranceGet(count float32, reverse bool) ([]Insurance, error) {

	queryParams := url.Values{}
	// add default headers if any
	queryParams.Add("count", fmt.Sprintf("%.0f", count))
	queryParams.Add("reverse", strconv.FormatBool(reverse))

	reqest, _ := http.NewRequest("GET", fmt.Sprintf("%s/insurance?%s", c.url, queryParams.Encode()), nil)
	httpResponse, err := c.client.Do(reqest)
	if err != nil {
		return nil, errors.New(fmt.Sprintf("insurance request error %v", err))
	}

	defer httpResponse.Body.Close()
	data, err := ioutil.ReadAll(httpResponse.Body)
	if err != nil {
		log.Println("insurance body error:", err)
	}
	if httpResponse.StatusCode != 200 {
		// log.Println("httpResponse.Body()", string(data))
		rep := new(ErrorRep)
		json.Unmarshal(data, &rep)
		return nil, errors.New(fmt.Sprintf("%s,%s", rep.err.Name, rep.err.Message))
	}
	rep := []Insurance{}
	// log.Println("PositionGet Json:", string(httpResponse.Body()))
	err = json.Unmarshal(data, &rep)
	if len(rep) == 0 || err != nil {
		return nil, errors.New(fmt.Sprintf("insurances data error %v. data:%s", err, string(data)))
	}
	return rep, nil
}

func (c *SimpleApi) TradeGet(symbol string, count float32, reverse bool) ([]Trade, error) {

	queryParams := url.Values{}
	// add default headers if any
	queryParams.Add("symbol", symbol)
	queryParams.Add("count", fmt.Sprintf("%.0f", count))
	queryParams.Add("reverse", strconv.FormatBool(reverse))

	reqest, _ := http.NewRequest("GET", fmt.Sprintf("%s/trade?%s", c.url, queryParams.Encode()), nil)
	httpResponse, err := c.client.Do(reqest)
	if err != nil {
		return nil, errors.New(fmt.Sprintf("trade request error %v", err))
	}

	defer httpResponse.Body.Close()
	data, err := ioutil.ReadAll(httpResponse.Body)
	if err != nil {
		log.Println("trade body error:", err)
	}
	if httpResponse.StatusCode != 200 {
		// log.Println("httpResponse.Body()", string(data))
		rep := new(ErrorRep)
		json.Unmarshal(data, &rep)
		return nil, errors.New(fmt.Sprintf("%s,%s", rep.err.Name, rep.err.Message))
	}
	rep := []Trade{}
	// log.Println("PositionGet Json:", string(httpResponse.Body()))
	err = json.Unmarshal(data, &rep)
	return rep, err
}
